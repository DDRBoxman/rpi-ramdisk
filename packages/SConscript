env = Environment(tools=[])

sysroot = Dir('../sysroot/sysroot')
toolchain = Dir('../sysroot/toolchain')

env['SYSROOT'] = sysroot
env['CROSS_COMPILE'] = toolchain.abspath + '/bin/arm-linux-gnueabihf-'

env.PrependENVPath('PATH', toolchain.abspath + '/bin')
env['ENV']['SYSROOT'] = sysroot.abspath


def package_walk(p, result):
    if p in result:
        return
    print(p)
    result[p] = SConscript(p + '/SConscript', 'env')
    for r in result[p]['requires']:
        package_walk(r, result)

packages = {}
for p in ['qmldemo']:
    package_walk(p, packages)


SConscript('../sysroot/SConscript', 'packages')

Return('packages')





######### leftover stuff from old Makefile #########

toolchain_mk = """
ARCH_CFLAGS := -pipe -march=armv7-a -marm -mthumb-interwork -mfpu=neon-vfpv4 -mtune=cortex-a7 -mabi=aapcs-linux -mfloat-abi=hard
"""

workarounds_mk = """
# Workarounds for libtool and gobject badness.

# pkg-config cannot handle sysroots properly, so we need to use a
# wrapper to adjust any paths it outputs.
# Also need to export PKG_CONFIG_LIBDIR in each package Makefile.
export PKG_CONFIG := $(BASEDIR)/../pkg-config
export PKG_CONFIG_DIR :=
export PKG_CONFIG_SYSROOT_DIR := $(SYSROOT)

# Set up Qemu for gobject introspection
# G-I binding generation is done by building a native executable and
# then running it to see what it exports. We need Qemu for this.
# Also need to export XDG_DATA_DIRS in each package Makefile.
export QEMU_LD_PREFIX := $(SYSROOT)
export LD_LIBRARY_PATH := $(SYSROOT)/opt/vc/lib

# tell g-ir-scanner about the sysroot.
export CFLAGS := --sysroot=$(SYSROOT) $(ARCH_CFLAGS)
export CPPFLAGS := --sysroot=$(SYSROOT)
export LDFLAGS := --sysroot=$(SYSROOT) -Wl,--unresolved-symbols=ignore-in-shared-libs
"""
