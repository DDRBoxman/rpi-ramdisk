from collections import OrderedDict

Import('env')

penv = env.Clone()

sysroot = Dir('../sysroot/sysroot')
toolchain = Dir('../sysroot/toolchain')

penv['SYSROOT'] = sysroot
penv['CROSS_COMPILE'] = toolchain.abspath + '/bin/arm-linux-gnueabihf-'

penv.PrependENVPath('PATH', toolchain.abspath + '/bin:')
penv['ENV']['SYSROOT'] = sysroot.abspath


#### pkg-config workarounds ####

# pkg-config cannot handle sysroots properly, so we need to use a
# wrapper to adjust any paths it outputs.
penv['ENV']['PKG_CONFIG'] = sysroot.abspath + '/../pkg-config'
penv['ENV']['PKG_CONFIG_DIR'] = ''
penv['ENV']['PKG_CONFIG_SYSROOT_DIR'] = sysroot.abspath
penv['ENV']['PKG_CONFIG_LIBDIR'] = ':'.join('{:s}{:s}'.format(sysroot.abspath, p) for p in [
    '/usr/lib/pkgconfig',
    '/usr/lib/arm-linux-gnueabihf/pkgconfig',
    '/usr/share/pkgconfig',
])

# inform pkg-config wrapper the location of the packages basedir
penv['ENV']['PACKAGES'] = Dir('.').abspath


#### gobject-introspection workarounds ####

# G-I binding generation is done by building a native executable and
# then running it to see what it exports. We need Qemu for this.
penv['ENV']['QEMU_LD_PREFIX'] = sysroot.abspath
penv['ENV']['LD_LIBRARY_PATH'] = sysroot.abspath + '/opt/vc/lib'

# search dirs for G-I
penv['ENV']['XDG_DATA_DIRS'] = ':'.join('{:s}{:s}'.format(sysroot.abspath, p) for p in [
    '/usr/share',
])

penv_gst = penv.Clone()

def package_walk(name, result, seen):
    if name in seen:
        return
    seen.add(name)
    p = SConscript(name + '/SConscript', 'sysroot penv penv_gst')
    for r in p['requires']:
        package_walk(r, result, seen)
    result[name] = p

packages = OrderedDict()
for p in ['qmlrss', 'gstreamer']:
    package_walk(p, packages, set())
print('Enabled packages:', ', '.join(packages.keys()))


SConscript('../sysroot/SConscript', 'env packages')

Return('packages')
